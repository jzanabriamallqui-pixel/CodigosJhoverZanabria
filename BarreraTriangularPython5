import numpy as np
import matplotlib.pyplot as plt
from scipy.special import airy

# Factor 2m/hbar^2 para la masa del electrón libre
# Valor aprox: 26.2468 eV^-1 nm^-2
K_FACTOR = 26.253666

def coeficiente_transmision(E_arr, V0, alpha):
    
    a = 0.0     # nm
    b = 4    # nm  
    c = b + alpha * (b - a) # nm
    
    q2 = K_FACTOR * V0
    
    alpha1 = (q2 / (b - a))**(1/3)
    alpha2 = -1.0 * (q2 / (c - b))**(1/3) 

    T_list = []
    R_list = []
    
    for E in E_arr:
        k = np.sqrt(K_FACTOR * E)
        k2 = k**2
       
        beta1 = - (1/alpha1**2) * ( (q2*a)/(b-a) + k2 )
        beta2 =   (1/alpha2**2) * ( (q2*c)/(c-b) - k2 )
        
        z1_a, z1_b = alpha1*a + beta1, alpha1*b + beta1
        z2_b, z2_c = alpha2*b + beta2, alpha2*c + beta2

        ai_1a, aip_1a, bi_1a, bip_1a = airy(z1_a)
        ai_1b, aip_1b, bi_1b, bip_1b = airy(z1_b)
        ai_2b, aip_2b, bi_2b, bip_2b = airy(z2_b)
        ai_2c, aip_2c, bi_2c, bip_2c = airy(z2_c)
        

        h1 = alpha1*alpha2 * bip_1b*bip_2c - alpha1*(1j*k) * bip_1b*bi_2c
        h2 = (1j*k)*alpha2 * bi_1b*bi_2c   - alpha2**2     * bi_1b*bip_2c
        h3 = alpha1*(1j*k) * bip_1b*bi_2b  - alpha2*(1j*k) * bi_1b*bip_2b
        h4 = alpha2**2     * bi_1b*bip_2b  - alpha1*alpha2 * bip_1b*bi_2b
        

        l1 = alpha1*alpha2 * aip_1b*aip_2c - alpha1*(1j*k) * aip_1b*ai_2c
        l2 = (1j*k)*alpha2 * ai_1b*ai_2c   - alpha2**2     * ai_1b*aip_2c
        l3 = alpha1*(1j*k) * ai_2b*aip_1b  - alpha2*(1j*k) * ai_1b*aip_2b
        l4 = alpha2**2     * ai_1b*aip_2b  - alpha1*alpha2 * ai_2b*aip_1b
        

        term_h = (h1*(1j*k*ai_1a*ai_2b + alpha1*aip_1a*ai_2b) +
                  h2*(1j*k*ai_1a*aip_2b + alpha1*aip_1a*aip_2b) +
                  h3*(1j*k*ai_1a*ai_2c + alpha1*aip_1a*ai_2c) +
                  h4*(1j*k*ai_1a*aip_2c + alpha1*aip_1a*aip_2c))
                  
        term_l = (l4*(1j*k*bi_1a*bip_2c + alpha1*bip_1a*bip_2c) +
                  l3*(1j*k*bi_1a*bi_2c + alpha1*bip_1a*bi_2c) +
                  l1*(1j*k*bi_1a*bi_2b + alpha1*bip_1a*bi_2b) +
                  l2*(1j*k*bi_1a*bip_2b + alpha1*bip_1a*bip_2b))
        

        r_11_sinexp = - (term_h + term_l)


        term_h_21 = (h1*(alpha1*aip_1a*ai_2b - 1j*k*ai_1a*ai_2b) +
                     h2*(alpha1*aip_1a*aip_2b - 1j*k*ai_1a*aip_2b) +
                     h3*(alpha1*aip_1a*ai_2c - 1j*k*ai_1a*ai_2c) +
                     h4*(alpha1*aip_1a*aip_2c - 1j*k*ai_1a*aip_2c))
        
        term_l_21 = (l4*(alpha1*bip_1a*bip_2c - 1j*k*bi_1a*bip_2c) +
                     l3*(alpha1*bip_1a*bi_2c - 1j*k*bi_1a*bi_2c) +
                     l1*(alpha1*bip_1a*bi_2b - 1j*k*bi_1a*bi_2b) +
                     l2*(alpha1*bip_1a*bip_2b - 1j*k*bi_1a*bip_2b))
                     
        r_21_sinexp = (term_h_21 + term_l_21) 
        
        Factor_T = 2 * k * alpha1 * alpha2 / np.pi**2
        
        T = np.abs(Factor_T / r_11_sinexp)**2
        R = np.abs(r_21_sinexp / r_11_sinexp)**2
        
        T_list.append(T)
        R_list.append(R)
    
    return np.array(T_list), np.array(R_list)

# Parámetros para la simulación
V0 = 8  # eV - altura de la barrera

# Valores de alpha a variar
alpha_values = [0.1, 0.5, 1.0, 3.0]

# Rango de energías
E_min = 0.01  # eV
E_max = 10   # eV
num_puntos = 500
E_arr = np.linspace(E_min, E_max, num_puntos)

# Crear la gráfica
plt.figure(figsize=(14, 10))

# Colores para las curvas
colors_T = plt.cm.Blues(np.linspace(0.4, 0.9, len(alpha_values)))
colors_R = plt.cm.Reds(np.linspace(0.4, 0.9, len(alpha_values)))
colors_TplusR = plt.cm.Greens(np.linspace(0.4, 0.9, len(alpha_values)))

# Calcular y graficar para cada valor de alpha
for i, alpha in enumerate(alpha_values): #Da el valor de alpha para la primera casilla de alpha_values. Esto siempre y cuando esté: enumerate
    # Calcular coeficientes para este alpha
    T, R = coeficiente_transmision(E_arr, V0, alpha)
    T_plus_R = T + R
    
    # Graficar T vs E
    plt.plot(E_arr, T, color=colors_T[i], linewidth=3, 
             label=f'T(E), α={alpha}')
    
    # Graficar R vs E
    plt.plot(E_arr, R, color=colors_R[i], linewidth=3, linestyle='--', 
             label=f'R(E), α={alpha}')
    
    # Graficar T+R vs E
    plt.plot(E_arr, T_plus_R, color=colors_TplusR[i], linewidth=1, linestyle=':', 
             label=f'T+R(E), α={alpha}')

# Línea vertical en V0 para referencia
plt.axvline(x=V0, color='k', linestyle='-', alpha=0.5, linewidth=1, label=f'V₀ = {V0} eV')

# Configuración de la gráfica
plt.xlabel('Energía E (eV)', fontsize=12)
plt.ylabel('Coeficientes', fontsize=12)
plt.title('Barrera Triangular: Coeficientes vs Energía\nVariando α = (c-b)/(b-a)', fontsize=14)
plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left', fontsize=10)
plt.grid(True, alpha=0.3)
plt.ylim(-0.1, 1.5)

# Mostrar la gráfica
plt.tight_layout()
plt.show()



