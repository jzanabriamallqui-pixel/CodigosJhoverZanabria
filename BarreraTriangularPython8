import numpy as np
import matplotlib.pyplot as plt
from scipy.special import airy
from matplotlib.widgets import Slider, Button

# Factor 2m/hbar^2 para la masa del electrón libre
# Valor aprox: 26.2468 eV^-1 nm^-2
K_FACTOR = 26.2468 

def coeficiente_transmision(E_arr, V0, alpha):
    
    a = 2     # nm
    b = 4    # nm  
    c = b + alpha * (b - a) # nm
    
    q2 = K_FACTOR * V0
    
    alpha1 = (q2 / (b - a))**(1/3)
    alpha2 = -1.0 * (q2 / (c - b))**(1/3) 

    T_list = []
    R_list = []
    
    for E in E_arr:
        k = np.sqrt(K_FACTOR * E)
        k2 = k**2
       
        beta1 = - (1/alpha1**2) * ( (q2*a)/(b-a) + k2 )
        beta2 =   (1/alpha2**2) * ( (q2*c)/(c-b) - k2 )
        
        z1_a, z1_b = alpha1*a + beta1, alpha1*b + beta1
        z2_b, z2_c = alpha2*b + beta2, alpha2*c + beta2

        ai_1a, aip_1a, bi_1a, bip_1a = airy(z1_a)
        ai_1b, aip_1b, bi_1b, bip_1b = airy(z1_b)
        ai_2b, aip_2b, bi_2b, bip_2b = airy(z2_b)
        ai_2c, aip_2c, bi_2c, bip_2c = airy(z2_c)
        

        h1 = alpha1*alpha2 * bip_1b*bip_2c - alpha1*(1j*k) * bip_1b*bi_2c
        h2 = (1j*k)*alpha2 * bi_1b*bi_2c   - alpha2**2     * bi_1b*bip_2c
        h3 = alpha1*(1j*k) * bip_1b*bi_2b  - alpha2*(1j*k) * bi_1b*bip_2b
        h4 = alpha2**2     * bi_1b*bip_2b  - alpha1*alpha2 * bip_1b*bi_2b
        

        l1 = alpha1*alpha2 * aip_1b*aip_2c - alpha1*(1j*k) * aip_1b*ai_2c
        l2 = (1j*k)*alpha2 * ai_1b*ai_2c   - alpha2**2     * ai_1b*aip_2c
        l3 = alpha1*(1j*k) * ai_2b*aip_1b  - alpha2*(1j*k) * ai_1b*aip_2b
        l4 = alpha2**2     * ai_1b*aip_2b  - alpha1*alpha2 * ai_2b*aip_1b
        

        term_h = (h1*(1j*k*ai_1a*ai_2b + alpha1*aip_1a*ai_2b) +
                  h2*(1j*k*ai_1a*aip_2b + alpha1*aip_1a*aip_2b) +
                  h3*(1j*k*ai_1a*ai_2c + alpha1*aip_1a*ai_2c) +
                  h4*(1j*k*ai_1a*aip_2c + alpha1*aip_1a*aip_2c))
                  
        term_l = (l4*(1j*k*bi_1a*bip_2c + alpha1*bip_1a*bip_2c) +
                  l3*(1j*k*bi_1a*bi_2c + alpha1*bip_1a*bi_2c) +
                  l1*(1j*k*bi_1a*bi_2b + alpha1*bip_1a*bi_2b) +
                  l2*(1j*k*bi_1a*bip_2b + alpha1*bip_1a*bip_2b))
        

        r_11_sinexp = - (term_h + term_l)


        term_h_21 = (h1*(alpha1*aip_1a*ai_2b - 1j*k*ai_1a*ai_2b) +
                     h2*(alpha1*aip_1a*aip_2b - 1j*k*ai_1a*aip_2b) +
                     h3*(alpha1*aip_1a*ai_2c - 1j*k*ai_1a*ai_2c) +
                     h4*(alpha1*aip_1a*aip_2c - 1j*k*ai_1a*aip_2c))
        
        term_l_21 = (l4*(alpha1*bip_1a*bip_2c - 1j*k*bi_1a*bip_2c) +
                     l3*(alpha1*bip_1a*bi_2c - 1j*k*bi_1a*bi_2c) +
                     l1*(alpha1*bip_1a*bi_2b - 1j*k*bi_1a*bi_2b) +
                     l2*(alpha1*bip_1a*bip_2b - 1j*k*bi_1a*bip_2b))
                     
        r_21_sinexp = (term_h_21 + term_l_21) 
        
        Factor_T = 2 * k * alpha1 * alpha2 / np.pi**2
        
        T = np.abs(Factor_T / r_11_sinexp)**2
        R = np.abs(r_21_sinexp / r_11_sinexp)**2
        
        T_list.append(T)
        R_list.append(R)
    
    return np.array(T_list), np.array(R_list)

# Parámetros iniciales
V0_inicial = 8.0    # eV
alpha_inicial = 1.0  # Valor inicial para alpha

# Rango de energías
E_min = 0.01  # eV
E_max = 15    # eV
num_puntos = 500
E_arr = np.linspace(E_min, E_max, num_puntos)

# Rangos para los sliders
V0_min = 0.1
V0_max = 15.0
alpha_min = 0.0
alpha_max = 10.0

# Crear la figura con espacio para los sliders
fig, ax = plt.subplots(figsize=(14, 10))
plt.subplots_adjust(bottom=0.25)  # Más espacio para los dos sliders

# Calcular datos iniciales
T_initial, R_initial = coeficiente_transmision(E_arr, V0_inicial, alpha_inicial)
T_plus_R_initial = T_initial + R_initial

# Crear las líneas de la gráfica
line_T, = ax.plot(E_arr, T_initial, 'b-', linewidth=3, label='T(E)')
line_R, = ax.plot(E_arr, R_initial, 'r-', linewidth=3, linestyle='--', label='R(E)')
line_TplusR, = ax.plot(E_arr, T_plus_R_initial, 'g-', linewidth=1, linestyle=':', label='T+R(E)')

# Línea vertical para V0
vline_V0 = ax.axvline(x=V0_inicial, color='k', linestyle='-', alpha=0.7, linewidth=2, label=f'V₀ = {V0_inicial} eV')

# Configuración de la gráfica
ax.set_xlim(E_min, E_max)
ax.set_ylim(-0.1, 1.5)
ax.set_xlabel('Energía E (eV)', fontsize=12)
ax.set_ylabel('Coeficientes', fontsize=12)
ax.set_title(f'Barrera Triangular: Coeficientes vs Energía\nV₀ = {V0_inicial:.1f} eV, α = {alpha_inicial:.1f}', fontsize=14)
ax.legend(loc='upper right', fontsize=10)
ax.grid(True, alpha=0.3)

# Texto informativo
info_text = ax.text(0.02, 0.95, '', transform=ax.transAxes, fontsize=11,
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.9))

# Actualizar el texto informativo
def update_info_text(V0, alpha):
    info_text.set_text(f'V₀ = {V0:.1f} eV\nα = {alpha:.2f}\nPosición c = {4 + alpha * (4 - 0):.1f} nm')

# Crear sliders
# Slider para V0
ax_slider_V0 = plt.axes([0.2, 0.15, 0.6, 0.03])
slider_V0 = Slider(
    ax=ax_slider_V0,
    label='Altura de Barrera V₀ (eV)',
    valmin=V0_min,
    valmax=V0_max,
    valinit=V0_inicial,
)

# Slider para alpha
ax_slider_alpha = plt.axes([0.2, 0.10, 0.6, 0.03])
slider_alpha = Slider(
    ax=ax_slider_alpha,
    label='Parámetro de Asimetría α',
    valmin=alpha_min,
    valmax=alpha_max,
    valinit=alpha_inicial,
)

# Función para actualizar la gráfica
def update(val):
    # Obtener valores actuales de los sliders
    V0 = slider_V0.val
    alpha = slider_alpha.val
    
    # Calcular nuevos coeficientes
    T, R = coeficiente_transmision(E_arr, V0, alpha)
    T_plus_R = T + R
    
    # Actualizar datos de las líneas
    line_T.set_ydata(T)
    line_R.set_ydata(R)
    line_TplusR.set_ydata(T_plus_R)
    
    # Actualizar línea vertical de V0
    vline_V0.set_xdata([V0, V0])
    
    # Actualizar título y texto informativo
    ax.set_title(f'Barrera Triangular: Coeficientes vs Energía\nV₀ = {V0:.1f} eV, α = {alpha:.2f}', fontsize=14)
    update_info_text(V0, alpha)
    
    # Actualizar leyenda de la línea vertical
    vline_V0.set_label(f'V₀ = {V0:.1f} eV')
    ax.legend(loc='upper right', fontsize=10)
    
    # Redibujar la gráfica
    fig.canvas.draw_idle()

# Conectar los sliders a la función de actualización
slider_V0.on_changed(update)
slider_alpha.on_changed(update)

# Botones de reset
ax_button_reset = plt.axes([0.8, 0.02, 0.1, 0.04])
button_reset = Button(ax_button_reset, 'Reset')

def reset(event):
    slider_V0.set_val(V0_inicial)
    slider_alpha.set_val(alpha_inicial)

button_reset.on_clicked(reset)

# Botones para valores predefinidos de alpha
# Crear un axes para los botones de alpha
ax_buttons_alpha = plt.axes([0.1, 0.02, 0.15, 0.08])
ax_buttons_alpha.set_xticks([])
ax_buttons_alpha.set_yticks([])
ax_buttons_alpha.set_title('Valores α rápidos:', fontsize=10)

# Función para establecer alpha
def set_alpha(val):
    slider_alpha.set_val(val)

# Crear botones para valores comunes de alpha
ax_alpha_0 = plt.axes([0.11, 0.02, 0.04, 0.03])
button_alpha_0 = Button(ax_alpha_0, 'α=0')
button_alpha_0.on_clicked(lambda x: set_alpha(0.0))

ax_alpha_1 = plt.axes([0.16, 0.02, 0.04, 0.03])
button_alpha_1 = Button(ax_alpha_1, 'α=1')
button_alpha_1.on_clicked(lambda x: set_alpha(1.0))

ax_alpha_3 = plt.axes([0.11, 0.06, 0.04, 0.03])
button_alpha_3 = Button(ax_alpha_3, 'α=3')
button_alpha_3.on_clicked(lambda x: set_alpha(3.0))

ax_alpha_5 = plt.axes([0.16, 0.06, 0.04, 0.03])
button_alpha_5 = Button(ax_alpha_5, 'α=5')
button_alpha_5.on_clicked(lambda x: set_alpha(5.0))

# Actualizar texto informativo inicial
update_info_text(V0_inicial, alpha_inicial)

print("Controles disponibles:")
print("- Slider superior: Controla V₀ (altura de la barrera)")
print("- Slider inferior: Controla α (parámetro de asimetría)")
print("- Botones rápidos: Valores predefinidos de α")
print("- Botón Reset: Vuelve a los valores iniciales")

plt.show()
