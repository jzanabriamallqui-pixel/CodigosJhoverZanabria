import numpy as np
import matplotlib.pyplot as plt
from scipy.special import airy
import matplotlib.animation as animation
from matplotlib.widgets import Slider

# Factor 2m/hbar^2 para la masa del electrón libre
# Valor aprox: 26.2468 eV^-1 nm^-2
K_FACTOR = 26.253666

def coeficiente_transmision(E_arr, V0, alpha):
    
    a = 0.0     # nm
    b = 1    # nm  
    c = b + alpha * (b - a) # nm
    
    q2 = K_FACTOR * V0
    
    alpha1 = (q2 / (b - a))**(1/3)
    alpha2 = -1.0 * (q2 / (c - b))**(1/3) 

    T_list = []
    R_list = []
    
    for E in E_arr:
        k = np.sqrt(K_FACTOR * E)
        k2 = k**2
       
        beta1 = - (1/alpha1**2) * ( (q2*a)/(b-a) + k2 )
        beta2 =   (1/alpha2**2) * ( (q2*c)/(c-b) - k2 )
        
        z1_a, z1_b = alpha1*a + beta1, alpha1*b + beta1
        z2_b, z2_c = alpha2*b + beta2, alpha2*c + beta2

        ai_1a, aip_1a, bi_1a, bip_1a = airy(z1_a)
        ai_1b, aip_1b, bi_1b, bip_1b = airy(z1_b)
        ai_2b, aip_2b, bi_2b, bip_2b = airy(z2_b)
        ai_2c, aip_2c, bi_2c, bip_2c = airy(z2_c)
        

        h1 = alpha1*alpha2 * bip_1b*bip_2c - alpha1*(1j*k) * bip_1b*bi_2c
        h2 = (1j*k)*alpha2 * bi_1b*bi_2c   - alpha2**2     * bi_1b*bip_2c
        h3 = alpha1*(1j*k) * bip_1b*bi_2b  - alpha2*(1j*k) * bi_1b*bip_2b
        h4 = alpha2**2     * bi_1b*bip_2b  - alpha1*alpha2 * bip_1b*bi_2b
        

        l1 = alpha1*alpha2 * aip_1b*aip_2c - alpha1*(1j*k) * aip_1b*ai_2c
        l2 = (1j*k)*alpha2 * ai_1b*ai_2c   - alpha2**2     * ai_1b*aip_2c
        l3 = alpha1*(1j*k) * ai_2b*aip_1b  - alpha2*(1j*k) * ai_1b*aip_2b
        l4 = alpha2**2     * ai_1b*aip_2b  - alpha1*alpha2 * ai_2b*aip_1b
        

        term_h = (h1*(1j*k*ai_1a*ai_2b + alpha1*aip_1a*ai_2b) +
                  h2*(1j*k*ai_1a*aip_2b + alpha1*aip_1a*aip_2b) +
                  h3*(1j*k*ai_1a*ai_2c + alpha1*aip_1a*ai_2c) +
                  h4*(1j*k*ai_1a*aip_2c + alpha1*aip_1a*aip_2c))
                  
        term_l = (l4*(1j*k*bi_1a*bip_2c + alpha1*bip_1a*bip_2c) +
                  l3*(1j*k*bi_1a*bi_2c + alpha1*bip_1a*bi_2c) +
                  l1*(1j*k*bi_1a*bi_2b + alpha1*bip_1a*bi_2b) +
                  l2*(1j*k*bi_1a*bip_2b + alpha1*bip_1a*bip_2b))
        

        r_11_sinexp = - (term_h + term_l)


        term_h_21 = (h1*(alpha1*aip_1a*ai_2b - 1j*k*ai_1a*ai_2b) +
                     h2*(alpha1*aip_1a*aip_2b - 1j*k*ai_1a*aip_2b) +
                     h3*(alpha1*aip_1a*ai_2c - 1j*k*ai_1a*ai_2c) +
                     h4*(alpha1*aip_1a*aip_2c - 1j*k*ai_1a*aip_2c))
        
        term_l_21 = (l4*(alpha1*bip_1a*bip_2c - 1j*k*bi_1a*bip_2c) +
                     l3*(alpha1*bip_1a*bi_2c - 1j*k*bi_1a*bi_2c) +
                     l1*(alpha1*bip_1a*bi_2b - 1j*k*bi_1a*bi_2b) +
                     l2*(alpha1*bip_1a*bip_2b - 1j*k*bi_1a*bip_2b))
                     
        r_21_sinexp = (term_h_21 + term_l_21) 
        
        Factor_T = 2 * k * alpha1 * alpha2 / np.pi**2
        
        T = np.abs(Factor_T / r_11_sinexp)**2
        R = np.abs(r_21_sinexp / r_11_sinexp)**2
        
        T_list.append(T)
        R_list.append(R)
    
    return np.array(T_list), np.array(R_list)

# Parámetros para la simulación
V0 = 2  # eV - altura de la barrera

# Rango de energías
E_min = 0.01  # eV
E_max = 10   # eV
num_puntos = 500
E_arr = np.linspace(E_min, E_max, num_puntos)

# Rango de alpha para la animación
alpha_min = 0.0
alpha_max = 15.0
num_frames = 500  # Número de frames en la animación

# Crear la figura y ejes
fig, ax = plt.subplots(figsize=(14, 10))
plt.subplots_adjust(bottom=0.2)  # Espacio para el slider

# Inicializar líneas vacías
line_T, = ax.plot([], [], 'b-', linewidth=3, label='T(E)')
line_R, = ax.plot([], [], 'r-', linewidth=3, linestyle='--', label='R(E)')
line_TplusR, = ax.plot([], [], 'g-', linewidth=1, linestyle=':', label='T+R(E)')

# Línea vertical en V0
vline_V0 = ax.axvline(x=V0, color='k', linestyle='-', alpha=0.5, linewidth=1, label=f'V₀ = {V0} eV')

# Configuración de la gráfica
ax.set_xlim(E_min, E_max)
ax.set_ylim(-0.1, 1.5)
ax.set_xlabel('Energía E (eV)', fontsize=12)
ax.set_ylabel('Coeficientes', fontsize=12)
ax.set_title('Barrera Triangular: Coeficientes vs Energía - α = 0.0', fontsize=14)
ax.legend(loc='upper right', fontsize=10)
ax.grid(True, alpha=0.3)

# Texto para mostrar el valor actual de alpha
alpha_text = ax.text(0.02, 0.95, '', transform=ax.transAxes, fontsize=12,
                    bbox=dict(boxstyle="round,pad=0.3", facecolor="white", alpha=0.8))

# Función de inicialización para la animación
def init():
    line_T.set_data([], [])
    line_R.set_data([], [])
    line_TplusR.set_data([], [])
    alpha_text.set_text('α = 0.00')
    return line_T, line_R, line_TplusR, alpha_text

# Función de animación que se llama para cada frame
def animate(i):
    # Calcular alpha para este frame
    alpha = alpha_min + (alpha_max - alpha_min) * (i / (num_frames - 1))
    
    # Calcular coeficientes
    T, R = coeficiente_transmision(E_arr, V0, alpha)
    T_plus_R = T + R
    
    # Actualizar datos de las líneas
    line_T.set_data(E_arr, T)
    line_R.set_data(E_arr, R)
    line_TplusR.set_data(E_arr, T_plus_R)
    
    # Actualizar título y texto
    ax.set_title(f'Barrera Triangular: Coeficientes vs Energía - α = {alpha:.2f}', fontsize=14)
    alpha_text.set_text(f'α = {alpha:.2f}')
    
    return line_T, line_R, line_TplusR, alpha_text

# Crear la animación
ani = animation.FuncAnimation(
    fig, animate, frames=num_frames, init_func=init,
    blit=True, interval=100, repeat=True
)

# Añadir slider para control manual
ax_slider = plt.axes([0.2, 0.05, 0.6, 0.03])
slider = Slider(ax_slider, 'α', alpha_min, alpha_max, valinit=alpha_min)

# Función para actualizar cuando se mueve el slider
def update_slider(val):
    alpha = slider.val
    T, R = coeficiente_transmision(E_arr, V0, alpha)
    T_plus_R = T + R
    
    line_T.set_data(E_arr, T)
    line_R.set_data(E_arr, R)
    line_TplusR.set_data(E_arr, T_plus_R)
    
    ax.set_title(f'Barrera Triangular: Coeficientes vs Energía - α = {alpha:.2f}', fontsize=14)
    alpha_text.set_text(f'α = {alpha:.2f}')
    fig.canvas.draw_idle()

slider.on_changed(update_slider)

plt.show()

# Opcional: Guardar la animación como GIF (descomenta si quieres guardarla)
# ani.save('barrera_triangular_animacion.gif', writer='pillow', fps=10)
